"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const coc_nvim_1 = require("coc.nvim");
const coc_nvim_2 = require("coc.nvim");
const tunnel_1 = __importDefault(require("tunnel"));
const follow_redirects_1 = require("follow-redirects");
const url_1 = require("url");
function fileURLToPath(x) {
    return coc_nvim_2.Uri.parse(x).fsPath;
}
exports.fileURLToPath = fileURLToPath;
function sleep(ms) {
    return new Promise((resolve, __) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function ensurePathExists(targetPath) {
    // Ensure that the path exists
    try {
        fs.mkdirSync(targetPath);
    }
    catch (e) {
        // If the exception isn't to indicate that the folder exists already, rethrow it.
        if (e.code !== "EEXIST") {
            throw e;
        }
    }
}
exports.ensurePathExists = ensurePathExists;
function getPipePath(pipeName) {
    if (os.platform() === "win32") {
        return "\\\\.\\pipe\\" + pipeName;
    }
    else {
        // Windows uses NamedPipes where non-Windows platforms use Unix Domain Sockets.
        // This requires connecting to the pipe file in different locations on Windows vs non-Windows.
        return path.join(os.tmpdir(), `CoreFxPipe_${pipeName}`);
    }
}
exports.getPipePath = getPipePath;
function checkIfFileExists(filePath) {
    try {
        fs.accessSync(filePath, fs.constants.R_OK);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.checkIfFileExists = checkIfFileExists;
function getTimestampString() {
    const time = new Date();
    return `[${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}]`;
}
exports.getTimestampString = getTimestampString;
function isWindowsOS() {
    return os.platform() === "win32";
}
exports.isWindowsOS = isWindowsOS;
function getCurrentSelection(mode) {
    return __awaiter(this, void 0, void 0, function* () {
        let doc = yield coc_nvim_1.workspace.document;
        if (mode === "v" || mode === "V") {
            let [from,] = yield doc.buffer.mark("<");
            let [to,] = yield doc.buffer.mark(">");
            let result = [];
            for (let i = from; i <= to; ++i) {
                result.push(doc.getline(i - 1));
            }
            return result;
        }
        else if (mode === "n") {
            let line = yield coc_nvim_1.workspace.nvim.call('line', '.');
            return [doc.getline(line - 1)];
        }
        else if (mode === "i") {
            // TODO what to do in insert mode?
        }
        else if (mode === "t") {
            //TODO what to do in terminal mode?
        }
        return [];
    });
}
exports.getCurrentSelection = getCurrentSelection;
function getAgent(endpoint) {
    let key = endpoint.protocol.startsWith('https') ? 'HTTPS_PROXY' : 'HTTP_PROXY';
    let env = process.env[key] || process.env[key.toLowerCase()];
    if (env) {
        let noProxy = process.env.NO_PROXY || process.env.no_proxy;
        if (noProxy === '*') {
            env = null;
        }
        else if (noProxy) {
            // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
            const hostname = endpoint.hostname.replace(/^\.*/, '.').toLowerCase();
            const port = endpoint.port || endpoint.protocol.startsWith('https') ? '443' : '80';
            const noProxyList = noProxy.split(',');
            for (let i = 0, len = noProxyList.length; i < len; i++) {
                let noProxyItem = noProxyList[i].trim().toLowerCase();
                // no_proxy can be granular at the port level, which complicates things a bit.
                if (noProxyItem.indexOf(':') > -1) {
                    let noProxyItemParts = noProxyItem.split(':', 2);
                    let noProxyHost = noProxyItemParts[0].replace(/^\.*/, '.');
                    let noProxyPort = noProxyItemParts[1];
                    if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
                        env = null;
                        break;
                    }
                }
                else {
                    noProxyItem = noProxyItem.replace(/^\.*/, '.');
                    if (hostname.endsWith(noProxyItem)) {
                        env = null;
                        break;
                    }
                }
            }
        }
    }
    let proxy = coc_nvim_1.workspace.getConfiguration('http').get('proxy', '');
    if (!proxy && env) {
        proxy = env;
    }
    if (proxy) {
        proxy = proxy.replace(/^https?:\/\//, '').replace(/\/$/, '');
        let auth = proxy.includes('@') ? proxy.split('@', 2)[0] : '';
        let parts = auth.length ? proxy.slice(auth.length + 1).split(':') : proxy.split(':');
        if (parts.length > 1) {
            let agent = tunnel_1.default.httpsOverHttp({
                proxy: {
                    headers: {},
                    host: parts[0],
                    port: parseInt(parts[1], 10),
                    proxyAuth: auth
                }
            });
            return agent;
        }
    }
    return null;
}
exports.getAgent = getAgent;
function httpsGet(url, cb) {
    let endpoint = url_1.parse(url);
    return new Promise((resolve, reject) => {
        let options = {
            hostname: endpoint.hostname,
            port: endpoint.port,
            path: endpoint.path,
            method: 'GET',
            agent: getAgent(endpoint)
        };
        const req = follow_redirects_1.https.request(options, (res) => {
            if (res.statusCode != 200) {
                reject(new Error(`Invalid response from ${JSON.stringify(url)}: ${res.statusCode}`));
                return;
            }
            cb(resolve, reject, res);
        });
        req.setHeader('user-agent', 'coc.nvim');
        req.on('error', reject);
        req.end();
    });
}
exports.httpsGet = httpsGet;
function httpsGetJson(url) {
    return __awaiter(this, void 0, void 0, function* () {
        let content = yield coc_nvim_2.fetch(url);
        if (typeof (content) === "string") {
            return JSON.parse(content);
        }
        else {
            return content;
        }
    });
}
exports.httpsGetJson = httpsGetJson;
//# sourceMappingURL=utils.js.map